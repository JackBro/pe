/*
 * Copyright (c) 2008-2016, Integrity Project Ltd. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * Neither the name of the Integrity Project nor the names of its contributors
 * may be used to endorse or promote products derived from this software
 * without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE
 */

#ifndef __TBA_PE_NT_HEADER_H
#define __TBA_PE_NT_HEADER_H

/*
 * ntheader.h
 *
 * A wrapper over IMAGE_NT_HEADERS struct. Holds the information regarding to
 * the NT PE file format and it's sections.
 *
 * Author: Elad Raz <e@eladraz.com>
 */
#include "xStl/types.h"
#include "xStl/data/array.h"
#include "xStl/data/list.h"
#include "xStl/data/string.h"
#include "xStl/data/smartptr.h"
#include "xStl/os/virtualMemoryAccesser.h"
#include "xStl/stream/basicIO.h"
#include "xStl/stream/forkStream.h"
#include "xStl/stream/stringerStream.h"
#include "xStl/stream/memoryAccesserStream.h"
#include "pe/section.h"
#include "pe/ntsectionheader.h"

/*
 * Forward deceleration for output streams
 */
#ifdef PE_TRACE
    class cNtHeader;
    cStringerStream& operator << (cStringerStream& out,
                                  const cNtHeader& object);
#endif // PE_TRACE

// The reference-object module
class cNtHeader;
typedef cSmartPtr<cNtHeader> cNtHeaderPtr;




/*
 * Parse the PE header and sections for coff binary file format.
 */
class cNtHeader : public IMAGE_NT_HEADERS32
{
public:
    /*
     * Read the file-header from a file.
     *
     * See cNtHeader::read for more information
     */
    cNtHeader(basicInput& stream,
              addressNumericValue trueImageBase = 0,
              bool shouldReadSections = true,
              bool isMemory = false);

    /*
     * Read the file-header from a live PE image
     * NOTE: In this version of implementation 'isMemory' must be true
     *
     * See cNtHeader::read for more information
     */
    cNtHeader(cMemoryAccesserStream& stream,
              addressNumericValue trueImageBase = 0,
              bool shouldReadSections = true,
              bool isMemory = true);

    // Operator = and copy-constructor will auto-generated by the compiler

    /*
     * Copy-constructor.
     * Construct a new cNtHeader object and copy the data from IMAGE_NT_HEADERS
     * struct.
     */
    cNtHeader(const IMAGE_NT_HEADERS32& other);

    // Functions

    /*
     * Copy the data from another IMAGE_NT_HEADERS to this class.
     * Make the header valid.
     *
     * NOTE: This function doesn't change the previous relocation tables and the
     *       sections lists.
     */
    void changeNtHeader(const IMAGE_NT_HEADERS32& other);

    /*
     * Operator = IMAGE_NT_HEADERS.
     * See changeNtHeader.
     *
     * NOTE: This function delete all previous section-descriptors and
     *       relocations.
     */
    cNtHeader& operator = (const IMAGE_NT_HEADERS32& other);

    /*
     * Read a NT-PE file from a stream. The stream must be pointed to the
     * beginning of the PE file header.
     * This function take a snapshot from the image
     *
     * stream         - The stream to read the information from
     * shouldReadData - Set to true in order to read the entire content
     * isMemory       - Set to true in order to access the stream as memory
     *                  relocated stream
     *
     * If "shouldReadData" is true, the  handler will seek to the position of
     * the content of the section inside the stream and read all section
     * content. After the reading the function will return the pointer back to
     * it's position, after the IMAGE_SECTION_HEADER.
     *
     * If "isMemory" is true the stream will be treated as memory-stripped
     * representation of a PE file. This means that the stream is starting from
     * 'image-base-address' and in-order to read the data, it will be seeked to
     * the 'VirtualAddress' locations, instead of the 'RawAddress' location.
     *
     * Throw exception in case of reading error
     */
    void read(basicInput& stream,
              bool shouldReadSections = true,
              bool isMemory = false);

    /*
     * See cNtHeader::read.
     *
     * Read the NT-header file starting with the PE header. Instead of
     * snapshoting the image, this function uses live-image.
     *
     * NOTE: In this version of implementation 'isMemory' must be true
     */
    void read(cMemoryAccesserStream& stream,
              bool shouldReadSections = true,
              bool isMemory = true);

    /*
     * Write a NT-PE to a stream.
     *
     * stream          - The stream to write the information to
     * shouldWriteData - Set to true in order to write the entire content
     * isMemory        - Set to true in order to access the stream as memory
     *                   relocated stream
     *
     * If "shouldWriteData" is true, the  handler will seek to the position of
     * the content of the section inside the stream and write all section
     * content. After the write the function will return the pointer back to
     * it's position, after the IMAGE_SECTION_HEADER.
     *
     * If "isMemory" is true the stream will be treated as memory-stripped
     * representation of a PE file. This means that the stream is starting from
     * 'image-base-address' and in-order to read the data, it will be seeked to
     * the 'VirtualAddress' locations, instead of the 'RawAddress' location.
     *
     * Throw exception in case of writing error
     */
    void write(basicIO& stream,
               bool shouldWriteSections = true,
               bool isMemory = true);


    // Operation over the header

    // The .rdata contains uninitialized data. It will be filled with 'CD' code
    enum { IMAGE_RDATA_CELL_CODE = 0xCD };

    /*
     * Generate a new object which represent the virtual memory mapping of the
     * object.
     *
     * NOTE: The returned object is valid only-and-only if the current object,
     *       *this pointer is alive. Use extreme caution while keeping the
     *       returned object more than a function life-time.
     */
    cVirtualMemoryAccesserPtr getPeMemory() const;

    /*
     * Scans all the virtual-address sections and return the highest possiable
     * virtual address which is in used by this PE file.
     */
    uint calculatePeLastVirtualAddress() const;

    /*
     * Gets the list of all sections.
     *
     * sections - Will be filled with the list
     *
     * Returns true if the sections were read and 'sections' is valid,
     * false otherwise.
     */
    bool getSections(cList<cSectionPtr>& sections) const;

private:
    // The drawing function should be friend
    #ifdef PE_TRACE
    friend cStringerStream& operator << (cStringerStream& out,
                                         const cNtHeader& object);
    #endif // PE_TRACE

    /*
     * After reading the sections, use this function inorder to read the memory
     * portions which aren't map to a section. This memory can usally be the
     * fast-dll import table.
     */
    void readPrivate(cMemoryAccesserStream& stream);

    /*
     * Private PE memory mapper. Generated by the 'getPeMemory' subroutine.
     * The memory-accesser reads the memory using direct access to the content
     * of the sections.
     *
     * NOTE: The section can be read as a fully memory copy, and can be read
     *       as memory-reference pointer.
     *       The benefit of memory-copy is that a "snapshot" operation is
     *       performed and the image can be removed from the memory.
     *       Direct memory-accesser is faster but require maintenance.
     */
    class cNtPeFileMapping : public cVirtualMemoryAccesser {
    public:
        defaultEndianImpl;

        /*
         * Use the m_sections in order to read the memory
         */
        virtual bool memread(addressNumericValue address,
                             void* buffer,
                             uint length,
                             cFragmentsDescriptor* fragments = NULL) const;

        // Not implemented
        virtual bool write(addressNumericValue address,
                           const void* buffer,
                           uint length);
        // Return false.
        virtual bool isWritableInterface() const;

    private:
        // Only the cNtHeader can generate this object
        friend class cNtHeader;
        // Constructor
        cNtPeFileMapping(const cNtHeader* parent);
        // Deny copy-constructor and operator =
        cNtPeFileMapping(const cNtPeFileMapping& other);
        cNtPeFileMapping& operator = (const cNtPeFileMapping& other);
        // The parent object
        const cNtHeader* m_parent;
    };

    // Private members and data
    // Dual friendship
    friend class cNtPeFileMapping;

    // Whether or not we should read the PE sections
    bool m_shouldReadSections;

    // The list of all sections. See cNtSection
    cList<cSectionPtr> m_sections;

    // A list of loaded DLL, undocumented!
    cForkStreamPtr m_fastImportDll;

    // The optimization PE stream, can be NULL
    cForkStreamPtr m_memoryImage;

    // The true image base that the PE was loaded to
    addressNumericValue m_trueImageBase;
};

#endif // __TBA_PE_NT_HEADER_H

